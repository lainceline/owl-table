//(function () {
	var OwlInput = React.createClass({
		displayName: 'OwlInput',
		propTypes: {
			column: React.PropTypes.object.isRequired,
			value: React.PropTypes.node,
			row: React.PropTypes.object
		},
		keydown: function (event) {
			// Handling the focus of the input myself with tab and shift-tab is
			// automatically handling readjusting the scroll position of the table,
			// unlike the default behavior.  See handler in table react component
			switch (event.which) {
				case 9:
					event.preventDefault();
					break;
				default:
					break;
			}
		},
		transmitSaveEvent: function (event) {
			var node = $(this.getDOMNode());
			var props = this.props;

			node.trigger('owlTableUpdated', [props.column, props.row, event.target.value]);
		},
		render: function () {
			var props = this.props;

			var input;
			var options = props.column.options;

			var self = this;

			var optionList;

			switch (props.column.type) {
				case 'text':
				case 'number':
					input = React.createElement("input", {type: props.column.type, onBlur: self.transmitSaveEvent, defaultValue: props.value, onKeyDown: self.keydown, onChange: self.inputDidChange});
					break;
				case 'select': // fall through
				case 'select_one': // fall through
				case 'select_multiple':
					optionList = options.map(function (option, index) {
						return (
							React.createElement("option", {key: index, value: option.value}, 
								option.text
							)
						);
					});

					if (props.column.type === 'select_multiple') {
						input = React.createElement("select", {className: "swiftbox", multiple: true, defaultValue: props.value.split("||")}, 
									optionList
								);
					} else {
						input = React.createElement("select", {className: "swiftbox", defaultValue: props.value}, 
									optionList
								);
					}
					break;
				case 'radio':
					var radioName = props.column.field + '_' + props.row.id;
					optionList = options.map(function (option, index) {

						return (
							React.createElement("div", {key: index, className: "radio"}, 
								React.createElement("label", null, 
									React.createElement("input", {type: "radio", onChange: self.transmitSaveEvent, defaultValue: option.value, name: radioName}), 
									option.text
								)
							)
						);
					});

					input = React.createElement("div", null, optionList);
					break;
				default:
					break;
			}

			return input;
		}
	});
//})();

var OwlCell = React.createClass({
	displayName: 'OwlCell',
	propTypes: {
		column: React.PropTypes.object.isRequired,
		row: React.PropTypes.object,
		open: React.PropTypes.bool,
		editable: React.PropTypes.bool
	},
	getDefaultProps: function () {
		return {
			open: false,
			editable: true
		};
	},
	render: function () {
		var props = this.props;
		var content = React.createElement("span", {className: "owl-cell-value-label"}, props.row[props.column.field]);

		if (props.open === true) {
			content = React.createElement(OwlInput, {
						column: props.column, 
						value: props.row[props.column.field], 
						row: props.row, 
						tableDidChange: props.tableDidChange}
					);
		}

		return (
			React.createElement("td", {'data-field': props.column.field}, 
				props.editable === true ? content : (props.row[props.column.field] || '---')
			)
		);
	},
	componentDidUpdate: function () {

		var self = this;

		if (this.props.focusedCell !== false) {
			this.props.focusedCell.find('input').focus();
		}

		var swiftboxes = $(this.getDOMNode()).find('.swiftbox');

		if (swiftboxes.length > 0) {
			swiftboxes.swiftbox();

			swiftboxes.each(function (index, box) {

				$(box).off('change');

				$(box).on('change', function (event) {
					var node = $(self.getDOMNode());
					var props = self.props;

					var val = node.find('.swift-box-hidden-input').val();

					node.trigger('owlTableUpdated', [props.column, props.row, val]);
				});
			});
		}
	}
});

var OwlRow = React.createClass({
	displayName: 'OwlRow',
	propTypes: {
		data: React.PropTypes.object.isRequired,
		columns: React.PropTypes.array.isRequired,
		open: React.PropTypes.bool.isRequired,
		lockedCells: React.PropTypes.array
	},
	getInitialState: function () {
		return {
			open: false,
			focusedCell: false
		};
	},
	clickHandler: function (event) {
		var cell = $(event.target);
		// need to focus the input that was clicked
		if (event.target.nodeName !== 'TD') {
			cell = cell.closest('td');
		}

		this.setState({
			open: true,
			focusedCell: cell
		});
	},
	render: function () {
		var props = this.props;
		var state = this.state;

		var handler = this.clickHandler;

		var lockedCells = [];

		if (props.lockedCells) {
			lockedCells = props.lockedCells[props.data.id];

			if (lockedCells && lockedCells.constructor !== Array) {
				lockedCells = [lockedCells];
			} else {
				lockedCells = [];
			}
		}

		var cells = props.columns.map(function (column, index) {
			var editable = true;

			if (lockedCells.length > 0) {
				lockedCells.forEach(function (locked, index) {
					if (locked == column.field) {
						editable = false;
					}
				});
			}

			return (
				React.createElement(OwlCell, {column: column, row: props.data, editable: editable, focusedCell: state.focusedCell, open: props.open || state.open, key: index, tableDidChange: props.tableDidChange})
			);
		});

		return(
			React.createElement("tr", {className: props.className + " owl-row", key: props.key, onClick: this.clickHandler}, 
				cells
			)
		);
	}
});

var OwlTableReact = React.createClass({
	displayName: 'OwlTable',
	propTypes: {
		data: React.PropTypes.array.isRequired,
		columns: React.PropTypes.array.isRequired,
		tacky: React.PropTypes.object,
		lockedCells: React.PropTypes.array,
		massUpdate: React.PropTypes.bool
	},
	getDefaultProps: function () {
		return {
			tacky: {
				top: false,
				left: false
			},
			lockedCells: [],
			massUpdate: false
		};
	},
	getInitialState: function () {
		return {
			changedData: {},
			openRows: {}
		};
	},
	componentDidUpdate: function () {
		if (this.props.tacky) {
			$('.tacky').tacky();
		}
	},
	render: function () {
		var self = this;

		var props = self.props;
		var tackyTop = false;
		var tackyLeft = false;

		if (props.tacky) {
			if (props.tacky.top) {
				tackyTop = true;
			}

			if (props.tacky.left) {
				tackyLeft = props.tacky.left;
			}
		}

		var headers = props.columns.map(function (column, index) {
			return (
				React.createElement("th", {className: tackyTop ? 'tacky-top' : '', key: index, 'data-field': column.field}, 
					column.title || 'None'
				)
			);
		});

		var rows = props.data.map(function (datum, index) {

			var lockedForRow = _.find(props.lockedCells, function (value, index) {

				if (typeof value === 'object' && parseInt(Object.keys(value)[0]) === datum.id) {
					return true;
				}
			});

			return (
				React.createElement(OwlRow, {data: datum, lockedCells: lockedForRow, columns: props.columns, key: index, open: self.state.openRows[index] || false, tableDidChange: self.tableDidChange})
			);
		});

		if (props.massUpdate === true) {
			rows.unshift(
				React.createElement(OwlRow, {className: "owl-react-mass-update-row", data: {}, lockedCells: [], columns: props.columns, key: 9999, open: true, tableDidChange: self.tableDidChange})
			);
		}

		self.keyup = function (event) {
			var td = $(event.target).parent();
			var handled = false;

			switch (event.which) {
				case 9:
					if (event.shiftKey !== true) {
						td.next().children().focus();
					} else {
						td.prev().children().focus();
					}
					handled = true;
					break;
				default:
					break;
			}

			if (handled === true) {
				event.stopPropagation();
			}
		};

		return (
			React.createElement("table", {onKeyUp: self.keyup, className: "owl-table"}, 
				React.createElement("thead", null, 
					React.createElement("tr", null, 
					headers
					)
				), 
				React.createElement("tbody", null, 
					rows
				)
			)
		);
	}
});

(function(module) {
try {
  module = angular.module('owlTablePartials');
} catch (e) {
  module = angular.module('owlTablePartials', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('partials/export.html',
    '<div class="owl-export-controls"><span class="owl-control-label">Export:</span><span class="owl-export-buttons"><span type="button" ng-csv="data" filename="focus.csv" csv-header="exportCtrl.csvHeader()" class="owl-export-button-csv"></span><span class="owl-export-button-print"></span></span></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('owlTablePartials');
} catch (e) {
  module = angular.module('owlTablePartials', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('partials/filter.html',
    '<div class="owl-filter-controls"><span class="owl-control-label">Filters:</span><span class="owl-filter-buttons">OFF</span></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('owlTablePartials');
} catch (e) {
  module = angular.module('owlTablePartials', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('partials/pagination.html',
    '<div class="owl-pagination-buttons active"><button ng-click="owlCtrl.prevPage()" class="owl-pagination-button owl-previous-page">&lt; Prev</button><div class="owl-page-count">Page <input type="text" size="3" ng-model="owlCtrl.owlTable.page">&nbsp;&nbsp;of {{owlCtrl.owlTable.pages}}</div><button ng-click="owlCtrl.nextPage()" class="owl-pagination-button owl-next-page">Next &gt;</button></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('owlTablePartials');
} catch (e) {
  module = angular.module('owlTablePartials', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('partials/table.html',
    '<div class="container-fluid owl-wrapper"><div class="owl-top-controls"><owl-pagination></owl-pagination><owl-export-controls></owl-export-controls><owl-filter-controls></owl-filter-controls><span class="owl-top-control-right-buttons"><div ng-if="options.massUpdate === true" class="form-inline owl-top-control-right owl-top-control-mass-update"><div class="form-group"><div class="checkbox"><label><input type="checkbox" id="massUpdateToggle" value="true" ng-model="owlCtrl.massUpdate">Mass Update</label></div></div><div ng-if="owlCtrl.massUpdate" class="form-group"><button id="massUpdate" ng-click="massUpdate()" class="btn btn-sm btn-default">Run Mass Update</button></div></div><div ng-if="options.saveIndividualRows !== true" class="owl-top-control-right owl-top-control-save"><div ng-hide="saved !== true">Saved</div><button id="saveButton" ng-click="saveButtonClicked()" class="btn btn-sm btn-default">Save</button></div></span></div><div class="owl-table-wrapper table-responsive tacky"><div class="owl-table-inner-wrapper"><div ng-hide="loading === true" class="owl-react-container"></div><div ng-show="loading === true" class="owl-ajax-loading"><div class="owl-ajax-loading-interior"><div id="owl-spin"></div><p ng-show="takingAWhile !== true">Loading data...</p><p ng-show="takingAWhile === true">Sorry, things are taking a little longer than normal...</p></div></div></div></div><owl-pagination></owl-pagination></div>');
}]);
})();

angular.module(
	'owlTable',
	[
		'ngAnimate',
		'ngSanitize',
		'ngCsv',
		'owlTablePartials'
	]
);

(function () {
	angular.module('owlTable').constant('owlConstants', {
		defaults: {
			PER_PAGE: 25
		}
	});
})();

function owlResource ($http, owlConstants) {

	return function (options) {

		var saveUrl = '';

		if (typeof(options.saveUrl) !== 'undefined') {
			saveUrl = options.saveUrl;
		}

		var id = options.id;
		var column = options.column;
		var value = options.value;

		var data = [{
			id: options.id
		}];

		data[0][column] = value;

		return {
			id: options.id,
			column: options.column,
			value: options.value,
			save: function () {
				return $http({
					method: 'post',
					url: saveUrl,
					data: {
						data: data
					}
				});
			}
		};
	};
}

function owlTableService ($http, $rootScope, owlConstants) {
	var service = {};

	service.tables = [];

	service.page = 1;
	service.pages = 1;
	service.total = 0;
	service.count = owlConstants.defaults.PER_PAGE;

	service.lockedCells = [];

	service.registerTable = function (id, callback) {
		this.tables.push({
			id: id,
			callbacks: $.Callbacks().add(callback)
		});
	};

	service.tableWithId = function (id) {
		return this.tables.map(function (table) {
			if (table.id === id) {
				return table;
			}
		});
	};

	service.setCount = function (count) {
		this.count = count;
	};

	service.nextPage = function () {
		if (this.page < this.pages) {
			this.page += 1;
		}
	};

	service.prevPage = function () {
		if (this.page > 1) {
			this.page -= 1;
		}
	};

	// enables client-side pagination.
	service.paginate = function (settings) {

		if (typeof(settings.count) !== 'undefined') {
			this.count = settings.count;
		}

		this.pages = Math.ceil(settings.total / this.count);
		this.total = settings.total;
	};

	service.save = function (settings) {
		if (typeof(settings.where) === 'undefined') {
			throw 'OwlException: No save route provided to table!';
		}

		return $http({
			method: 'post',
			url: settings.where,
			data: {
				data: settings.changedData
			}
		});
	};

	service.lockCell = function (row, column) {
		// row is id
		// column is the field string ie 'first_name'

		this.lockedCells[row] = column;
		var cell = {};
		cell[row] = column;

		this.tables.forEach(function (table, index) {
			table.callbacks.fire('cellLocked', cell);
		});
	};

	service.unlockCell = function (row, column) {
		this.lockedCells = this.lockedCells.map(function (cell, key) {
			if (column !== cell && row !== key) {
				return cell;
			}
		});

		var cell = {};
		cell[row] = column;

		this.tables.forEach(function (table, index) {
			table.callbacks.fire('cellUnlocked', cell);
		});
	};

	return service;
}

angular.module('owlTable').service('owlTable', ['$http', '$rootScope', 'owlConstants', owlTableService])
	.service('owlResource', ['$http', 'owlConstants', owlResource]);

function owlTableDirective ($http, $timeout, owlTable, owlResource) {
	return {
		restrict: 'EA',
		scope: {
			data: '=',
			columns: '=',
			save: '@',
			tacky: '=owlTacky',
			options: '='
		},
		templateUrl: 'partials/table.html',
		controllerAs: 'owlCtrl',
		compile: function (tElem, tAttrs) {

			return function link (scope, elem, attrs) {
				var table;
				var rendered;
				var container = elem.find('.owl-react-container')[0];

				owlTable.registerTable(elem[0].id, function handleTableEvent (event, data) {
					var newLockedCells;

					switch (event) {
						case 'cellLocked':
							newLockedCells = React.addons.update(rendered.props.lockedCells, {
								$push: [data]
							});

							rendered.setProps({
								lockedCells: newLockedCells
							});
							break;
						case 'cellUnlocked':
							newLockedCells = rendered.props.lockedCells.filter(function (cell, index) {
								var cellField = cell[Object.keys(cell)[0]];
								var dataField = data[Object.keys(data)[0]];

								if (cellField !== dataField) {
									return true;
								}
							});

							rendered.setProps({
								lockedCells: newLockedCells
							});
							break;
						default:
							throw 'OwlException: Unhandled event in table ' + tElem[0].id;
					}
				});

				scope.loading = true;
				scope.takingAWhile = false;
				scope.saved = false;

				scope.owlCtrl.massUpdate = false;

				scope.lockedCells = owlTable.lockedCells;

				$timeout(function () {
					scope.takingAWhile = true;
				}, 5000);

				table = React.createElement(OwlTableReact, {
					data: scope.data,
					columns: scope.columns,
					tacky: scope.tacky,
					lockedCells: [],
					massUpdate: scope.owlCtrl.massUpdate
				});

				rendered = React.render(table, container);

				scope.$watchCollection('data', function (newValue, oldValue) {
					if (newValue !== oldValue) {
						rendered.setProps({
							data: scope.owlCtrl.dataForPage(owlTable.page)
						});

						scope.loading = false;
					}
				});

				scope.$watchCollection('columns', function (newValue, oldValue) {
					if (newValue !== oldValue) {
						rendered.setProps({
							columns: newValue
						});
					}
				});

				scope.$watchCollection('tacky', function (newValue) {
					rendered.setProps({
						tacky: newValue
					});
				});

				scope.$watch('owlCtrl.massUpdate', function (newValue) {
					console.log(newValue);
					rendered.setProps({
						massUpdate: newValue
					});
				});

				if (scope.options.saveIndividualRows) {
					elem.on('owlTableUpdated', function (event, column, row, value) {
						owlResource({
							id: row.id,
							column: column.field,
							value: value,
							saveUrl: scope.save
						}).save().then(function(response) {
							scope.saved = true;
							$timeout(function () {
								scope.saved = false;
							}, 2000);
						});
						event.stopPropagation();
					});
				}

				scope.saveButtonClicked = function (event) {
					scope.saving = true;

					owlTable.save({
						changedRows: rendered.state.changedData,
						where: scope.save
					}).then(function (response) {
						scope.saving = false;
						console.log('save successful');

						rendered.setState({
							changedData: {}
						});
					});
				};

				scope.owlCtrl.nextPage = function () {
					owlTable.nextPage();
					// set the table props to the data for the new page.
					rendered.setProps({
						data: scope.owlCtrl.dataForPage(owlTable.page)
					});
				};

				scope.owlCtrl.prevPage = function () {
					owlTable.prevPage();
					rendered.setProps({
						data: scope.owlCtrl.dataForPage(owlTable.page)
					});
				};

				var opts = {
					lines: 13, // The number of lines to draw
					length: 20, // The length of each line
					width: 10, // The line thickness
					radius: 30, // The radius of the inner circle
					corners: 1, // Corner roundness (0..1)
					rotate: 0, // The rotation offset
					direction: 1, // 1: clockwise, -1: counterclockwise
					color: '#000', // #rgb or #rrggbb or array of colors
					speed: 1, // Rounds per second
					trail: 60, // Afterglow percentage
					shadow: true, // Whether to render a shadow
					hwaccel: false, // Whether to use hardware acceleration
					className: 'spinner', // The CSS class to assign to the spinner
					zIndex: 2e9, // The z-index (defaults to 2000000000)
					top: '50%', // Top position relative to parent
					left: '50%' // Left position relative to parent
				};

				var target = document.getElementById('owl-spin');
				var spinner = new Spinner(opts).spin(target);
			};
		},
		controller: ['$scope', function ($scope) {
			this.owlTable = owlTable;

			this.dataForPage = function (page) {
				var data = $scope.data.slice(((page - 1) * this.owlTable.count), ((page * this.owlTable.count) - 1));

				return data;
			};
		}]
	};
}

function owlPagination (owlTable) {
	return {
		restrict: 'EA',
		require: '^owlTable',
		templateUrl: 'partials/pagination.html',
		compile: function (tElem, tAttrs) {
			return function link (scope, elem, attrs) {

			};
		}
	};
}

function owlFilterControls (owlTable) {
	return {
		restrict: 'EA',
		require: '^owlTable',
		templateUrl: 'partials/filter.html',
		compile: function (tElem, tAttrs) {
			return function link (scope, elem, attrs) {};
		}
	};
}

function owlExportControls (owlTable) {
	return {
		restrict: 'EA',
		require: '^owlTable',
		templateUrl: 'partials/export.html',
		controllerAs: 'exportCtrl',
		compile: function (tElem, tAttrs) {
			return function link (scope, elem, attrs) {};
		},
		controller: function ($scope) {
			this.csvHeader = function () {
				var header = [];
				header = $scope.columns.map(function (column, index) {
					return column.title;
				});

				return header;
			};
		}
	};
}

angular.module('owlTable')
	.directive('owlTable', ['$http', '$timeout', 'owlTable', 'owlResource', owlTableDirective])
	.directive('owlPagination', ['owlTable', owlPagination])
	.directive('owlFilterControls', ['owlTable', owlFilterControls])
	.directive('owlExportControls', ['owlTable', owlExportControls]);
